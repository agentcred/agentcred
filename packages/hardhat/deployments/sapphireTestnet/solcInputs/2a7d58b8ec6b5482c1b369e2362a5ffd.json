{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/ContentRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport \"./TrustScoreRegistry.sol\";\n\ninterface IAgentStaking {\n    function getStake(uint256 agentId) external view returns (uint256);\n    function slash(uint256 agentId, uint256 amount, string memory reason) external;\n}\n\n/**\n * @title ContentRegistry\n * @notice Anchors the public history of audited content on-chain.\n */\ncontract ContentRegistry is AccessControl {\n    bytes32 public constant AUDITOR_ROLE = keccak256(\"AUDITOR_ROLE\");\n    \n    // Slashing formula constants\n    uint8 public constant PASS_THRESHOLD = 51;        // Score >= 51 = no slash\n    uint8 public constant MILD_FAIL_THRESHOLD = 21;   // Score 21-50 = 5% slash\n    uint8 public constant BAD_FAIL_THRESHOLD = 1;     // Score 1-20 = 15% slash\n    // Score 0 = 30% slash (critical)\n    \n    uint16 public constant MILD_FAIL_BPS = 500;       // 5%\n    uint16 public constant BAD_FAIL_BPS = 1500;       // 15%\n    uint16 public constant CRITICAL_FAIL_BPS = 3000;  // 30%\n    uint16 public constant BPS_DENOMINATOR = 10000;   // 100%\n    \n    // Reference to AgentStaking contract\n    IAgentStaking public agentStaking;\n    // Reference to TrustScoreRegistry contract\n    TrustScoreRegistry public trustScoreRegistry;\n\n    enum Status {\n        Pending,\n        Published,\n        AuditedOk,\n        AuditedFail\n    }\n\n    struct Content {\n        string contentHash;\n        address author;\n        uint256 agentId;\n        Status status;\n        uint256 auditScore;\n        string uri;\n        uint256 timestamp;\n    }\n\n    // Mapping from contentHash to Content details\n    mapping(string => Content) public contents;\n\n    event ContentPublished(string contentHash, address indexed author, uint256 indexed agentId, string uri);\n    event ContentAudited(string indexed contentHash, bool ok, uint256 score);\n    event AgentStakingUpdated(address indexed newAgentStaking);\n    event TrustScoreRegistryUpdated(address indexed newTrustScoreRegistry);\n\n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Sets the AgentStaking contract address.\n     * @dev Only callable by admin.\n     * @param _agentStaking The address of the AgentStaking contract.\n     */\n    function setAgentStaking(address _agentStaking) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        agentStaking = IAgentStaking(_agentStaking);\n        emit AgentStakingUpdated(_agentStaking);\n    }\n\n    /**\n     * @notice Sets the TrustScoreRegistry contract address.\n     * @dev Only callable by admin.\n     * @param _trustScoreRegistry The address of the TrustScoreRegistry contract.\n     */\n    function setTrustScoreRegistry(address _trustScoreRegistry) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        trustScoreRegistry = TrustScoreRegistry(_trustScoreRegistry);\n        emit TrustScoreRegistryUpdated(_trustScoreRegistry);\n    }\n\n    /**\n     * @notice Publishes new content to the registry.\n     * @param _contentHash The unique hash of the content.\n     * @param _author The address of the content author (user submitting through agent).\n     * @param _agentId The ID of the AI agent that generated the content.\n     * @param _uri The location where the full content is stored.\n     */\n    function publishContent(string memory _contentHash, address _author, uint256 _agentId, string memory _uri) external {\n        require(contents[_contentHash].timestamp == 0, \"Content already exists\");\n\n        contents[_contentHash] = Content({\n            contentHash: _contentHash,\n            author: _author,\n            agentId: _agentId,\n            status: Status.Pending,\n            auditScore: 0,\n            uri: _uri,\n            timestamp: block.timestamp\n        });\n\n        emit ContentPublished(_contentHash, _author, _agentId, _uri);\n    }\n\n    /**\n     * @notice Updates the audit result for a specific content.\n     * @dev Only callable by accounts with AUDITOR_ROLE.\n     * @param _contentHash The unique hash of the content.\n     * @param _ok Whether the audit passed or failed.\n     * @param _score The numerical score (0-100).\n     */\n    function updateAuditResult(string memory _contentHash, bool _ok, uint256 _score) external onlyRole(AUDITOR_ROLE) {\n        require(contents[_contentHash].timestamp != 0, \"Content does not exist\");\n        require(_score <= 100, \"Score must be between 0 and 100\");\n\n        Content storage content = contents[_contentHash];\n        content.status = _ok ? Status.AuditedOk : Status.AuditedFail;\n        content.auditScore = _score;\n\n        // Update Reputation\n        if (address(trustScoreRegistry) != address(0)) {\n            _updateReputation(content.author, content.agentId, uint8(_score));\n        }\n\n        // If audit failed and AgentStaking is set, calculate and apply slash\n        if (!_ok && address(agentStaking) != address(0)) {\n            _handleSlashing(content.agentId, uint8(_score));\n        }\n\n        emit ContentAudited(_contentHash, _ok, _score);\n    }\n\n    /**\n     * @notice Updates reputation based on audit score.\n     * @param author The author of the content.\n     * @param agentId The agent ID.\n     * @param score The audit score.\n     */\n    function _updateReputation(address author, uint256 agentId, uint8 score) internal {\n        int256 userDelta;\n        int256 agentDelta;\n\n        if (score >= PASS_THRESHOLD) {\n            // Pass (51-100)\n            userDelta = 1;\n            agentDelta = 2;\n        } else if (score >= MILD_FAIL_THRESHOLD) {\n            // Soft Fail (21-50)\n            userDelta = -1;\n            agentDelta = -2;\n        } else {\n            // Hard Fail (0-20)\n            userDelta = -2;\n            agentDelta = -4;\n        }\n\n        trustScoreRegistry.adjustUserReputation(author, userDelta);\n        trustScoreRegistry.adjustAgentReputation(agentId, agentDelta);\n    }\n\n    /**\n     * @notice Calculates and applies slashing based on audit score.\n     * @dev Internal function called when audit fails.\n     * @param _agentId The ID of the agent to slash.\n     * @param _score The audit score (0-100).\n     */\n    function _handleSlashing(uint256 _agentId, uint8 _score) internal {\n        uint256 stake = agentStaking.getStake(_agentId);\n        if (stake == 0) return;\n\n        uint16 bps; // basis points, out of BPS_DENOMINATOR\n\n        if (_score >= PASS_THRESHOLD) {\n            return; // no slash for passing scores\n        } else if (_score >= MILD_FAIL_THRESHOLD) {\n            bps = MILD_FAIL_BPS;    // 5% for mild fail\n        } else if (_score >= BAD_FAIL_THRESHOLD) {\n            bps = BAD_FAIL_BPS;     // 15% for bad fail\n        } else {\n            bps = CRITICAL_FAIL_BPS; // 30% for critical failure\n        }\n\n        uint256 amount = stake * bps / BPS_DENOMINATOR;\n        if (amount > 0) {\n            string memory reason = string(abi.encodePacked(\"Audit failed with score: \", _uint2str(_score)));\n            agentStaking.slash(_agentId, amount, reason);\n        }\n    }\n\n    /**\n     * @notice Helper function to convert uint to string.\n     */\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"
    },
    "contracts/TrustScoreRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title TrustScoreRegistry\n * @notice Maintains reputation scores for users and agents.\n */\ncontract TrustScoreRegistry is AccessControl {\n    bytes32 public constant AUDITOR_ROLE = keccak256(\"AUDITOR_ROLE\");\n\n    // Mapping from user address to reputation score\n    mapping(address => int256) public userReputation;\n    // Mapping from agentId to reputation score\n    mapping(uint256 => int256) public agentReputation;\n\n    event UserReputationUpdated(address indexed user, int256 newScore, int256 delta);\n    event AgentReputationUpdated(uint256 indexed agentId, int256 newScore, int256 delta);\n\n    constructor() {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Adjusts the reputation score of a user.\n     * @dev Only callable by accounts with AUDITOR_ROLE.\n     * @param _user The address of the user.\n     * @param _delta The change in reputation score (positive or negative).\n     */\n    function adjustUserReputation(address _user, int256 _delta) external onlyRole(AUDITOR_ROLE) {\n        userReputation[_user] += _delta;\n        emit UserReputationUpdated(_user, userReputation[_user], _delta);\n    }\n\n    /**\n     * @notice Adjusts the reputation score of an agent.\n     * @dev Only callable by accounts with AUDITOR_ROLE.\n     * @param _agentId The ID of the agent.\n     * @param _delta The change in reputation score (positive or negative).\n     */\n    function adjustAgentReputation(uint256 _agentId, int256 _delta) external onlyRole(AUDITOR_ROLE) {\n        agentReputation[_agentId] += _delta;\n        emit AgentReputationUpdated(_agentId, agentReputation[_agentId], _delta);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}