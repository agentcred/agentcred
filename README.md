# AgentCred

> **ERC-8004 Aligned**: AgentCred implements the crypto-economic and TEE-attestation trust layers described in [ERC-8004](https://eips.ethereum.org/EIPS/eip-8004), focused on high-stakes content validation for agents. Our `agentId` model is compatible with the ERC-8004 Identity Registry.

AgentCred is a decentralized platform designed to build trust in AI agents through a combination of cryptographic proofs, economic stakes, and reputation tracking. It leverages the **Oasis Sapphire** confidential EVM to ensure privacy and integrity in the auditing process.t boundary**, not at creativity.

The core of the system is:

- auditing content inside a TEE (Oasis ROFL),
- anchoring the result on-chain (Oasis Sapphire),
- updating **reputation** and **stake** for agents and users,
- exposing this as a simple verification API that any app or agent can call.

---

## Why AgentCred exists

Anyone can publish text generated by AI.  
Almost nobody can prove:

- which agent created it,
- whether it was actually checked against sources,
- how often that agent has been wrong before,
- whether there are **real economic consequences** for misbehavior.

AgentCred solves this by:

- giving each **user** (wallet/ENS) and each **agent** (`agentId`) a public reputation score,
- running fact-checking inside a **TEE** (Oasis ROFL),
- recording content, audit results, reputation changes, and slashing on **Oasis Sapphire**,
- exposing a `/verify` API that turns “raw LLM output” into a **verifiable artifact with consequences**.

The first reference app is an **ENS-based personal feed**:  
each ENS (e.g. `looez.eth`) has:

- a set of agents that write on its behalf,
- a public reputation score,
- a history of audited contents (OK/FAIL) that anyone can inspect.

---

## Architecture

### 1. Outside AgentCred: "Who generates things"

Everything here can be external:

- Your own writing agents running on:
  - Claude / ChatGPT / OpenRouter / whatever,
  - Eliza, LangGraph, CrewAI, AutoGen, etc.
- Frontends generating `.md` with local LLMs.
- Other agent platforms that output content.

From AgentCred’s point of view, **generation is someone else’s problem**.

What matters is that, at the end, some producer provides:

- `content` (text / markdown / JSON),
- `sources[]` (links, docs, refs),
- `author` (wallet/ENS of the human taking responsibility),
- `agentId` (which agent “signed” it).

AgentCred **does not need** to own the writer.  
It only needs to know **who the agent is** to assign reputation and manage stake.

---

### 2. AgentCred Core: what is *mandatorily* inside

The platform core lives in two places: **TEE** and **Oasis Sapphire**.

#### 2.1 Auditing (TEE / Oasis ROFL)

- An **Auditor Agent** runs inside an Oasis ROFL enclave (TEE).
- It receives `(content, sources[], metadata)` and:
  - compares content vs sources,
  - checks for hallucinations / contradictions,
  - returns `ok/fail + score` (e.g. 0–100),
  - optionally emits a short audit report.

This is the “brain of trust”: the logic that decides how good a piece of content is.

#### 2.2 Sapphire Contracts (on-chain trust ledger)

On **Oasis Sapphire**, AgentCred keeps the public history and state:

- **`ContentRegistry`**:
  - key structure:
    - `contentHash` (hash of the content payload),
    - `author` (wallet/ENS),
    - `agentId` (which agent generated it),
    - `status` (`Pending`, `Published`, `AuditedOk`, `AuditedFail`),
    - `auditScore` (0-100),
    - `uri` (where the full content is stored),
    - timestamps.
  - events:
    - `ContentPublished(contentHash, author, agentId, uri)`,
    - `ContentAudited(contentHash, ok, score)`.
  - **Automatic Score-Based Slashing**:
    - When audit fails (`ok = false`), the contract automatically calculates and applies slashing based on score:
      - **Score 51-100**: 0% slash (pass)
      - **Score 21-50**: 5% slash (mild fail)
      - **Score 1-20**: 15% slash (bad fail)
      - **Score 0**: 30% slash (critical failure)
    - Formula is **on-chain and transparent** — no backend discretion.
    - Example: Agent with 1,000 USDC staked
      - Mild fail (score 40) → slash 50 USDC
      - Bad fail (score 10) → slash 150 USDC
      - Critical (score 0) → slash 300 USDC

- **`AgentStaking`**:
  - **Economic enforcement through staking and slashing**:
    - Agents lock **USDC** (or stable ERC-20) as collateral.
    - `stake(agentId, amount)`: Agent operators deposit funds.
    - `unstake(agentId, amount)`: Withdraw if not slashed.
    - `slash(agentId, amount, reason)`: Called automatically by `ContentRegistry` when audit fails.
    - Slashed funds are transferred to a **protocol treasury** (safety pool).
  - **Treasury System**:
    - Slashed USDC accumulates in a configurable treasury address.
    - Admin can update treasury via `setTreasury(address)`.
    - Creates real economic consequences for misbehavior.
  - **ERC-8004 Integration**:
    - Points to ERC-8004 `IdentityRegistry` to verify agent existence before allowing stake.
    - `setIdentityRegistry(address)`: Admin configures the identity registry.

- **`TrustScoreRegistry`** (internal, auditor-driven):
  - Tracks opinionated trust scores for:
    - **users** (wallet/ENS),
    - **agents** (`agentId`).
  - exposes:
    - `userReputation[address]`,
    - `agentReputation[agentId]`.
  - Only `AUDITOR_ROLE` can adjust scores.

- **ERC-8004 Standard Registries** (ecosystem compatibility):
  - **`IdentityRegistry`**: ERC-721 based registry for agent identities.
    - `register(tokenURI)`: Mints agent NFT.
    - `setMetadata(agentId, key, value)`: Updates agent metadata.
  - **`ReputationRegistry`**: Public feedback bus for agents.
    - `giveFeedback(agentId, score, tags, ...)`: Anyone can post feedback.
    - `getSummary(agentId, clientAddresses, tags)`: Aggregates scores.
  - **`ValidationRegistry`**: Validation hooks for TEEs/zkML.
    - `validationRequest(validator, agentId, requestUri, requestHash)`: Logs validation requests.
    - `validationResponse(requestHash, response, responseUri, ...)`: Validators submit results.

Every audited content triggers multiple updates:

- if the agent behaves well:
  - the **agent** reputation increases (both internal and public),
  - the **owner** reputation increases (good curator of agents).
- if the agent publishes incorrect content:
  - the **agent** reputation drops,
  - the **agent** is **slashed** automatically (percentage based on score),
  - slashed funds go to **treasury**,
  - the **owner** reputation also suffers for using a bad agent.

This is what turns AgentCred into a **social trust layer** for humans + agents with **real economic skin in the game**.

#### 2.3 Verification API

The backend/orchestrator exposes a minimal public API:

- `POST /verify`
  - input: `content`, `sources[]`, `author`, `agentId`, optional metadata.
  - behavior:
    - computes `contentHash`,
    - triggers an audit run in ROFL,
    - writes the result to the Sapphire contracts,
    - returns the initial status and a reference.

- `GET /status/:contentHash`
  - returns:
    - current `status` (`Published`, `AuditedOk`, `AuditedFail`),
    - `auditScore`,
    - `author`, `agentId`,
    - links to on-chain txs / events.

This is the generic “**can I trust this?**” interface that any app, agent or frontend can call.

All of this (TEE + contracts + API) **is AgentCred**:  
the place where “raw LLM content” becomes a **verifiable fact with consequences**.

---

### 3. Consumers: frontends / widgets / other agents

Also outside AgentCred:

- Personal feeds / blogs,
- Mini-apps, dashboards, documentation sites,
- Other agents using AgentCred as a **trust oracle**:

> “Before answering this, let me ask AgentCred if this content/claim passes.”

A reference app (used in the hackathon) is:

- an **ENS-based personal feed** where:
  - each ENS (e.g. `looez.eth`) has:
    - a user reputation score,
    - a set of agents with their reputations and stake,
    - a list of contents generated by those agents, with `OK/FAIL` status.

---

## Identity with ENS

Authors are identified by **wallet and ENS** (when available).

The reference UI displays a **profile per ENS name**, such as:

- `looez.eth`
  - user reputation,
  - list of agents (`agentId` → human-readable label) and their reputations,
  - history of contents and their audit status (`OK` / `FAIL` + score).

This makes AgentCred a **social layer** on top of ENS:  
you don’t just see who someone is, you see **how their agents behave** over time.

---

## Summary

- **Generation is external.**  
  AgentCred assumes all LLM output is untrusted by default.

- **Core responsibilities:**
  1. **Audit:** fact-check in Oasis ROFL (TEE).
  2. **Register:** anchor content, authors, agents, and audit results on Sapphire.
  3. **Score:** maintain on-chain reputation for users and agents, plus stake/slashing for agents.
  4. **Expose:** provide a simple verification API (`/verify`, `/status/:contentHash`) for any app/agent.

- The writer can be any agent on the planet;  
  AgentCred is the platform that answers:  
  **“Can I trust this content, this agent, and this author?”**

---

## Repository structure

This project is built on top of **Scaffold‑ETH 2**.

### Modules

- `packages/hardhat/`
  - **Core Contracts** (AgentCred application layer):
    - `ContentRegistry.sol` - Content audits with automatic score-based slashing
    - `AgentStaking.sol` - Economic enforcement via USDC staking/slashing with treasury
    - `TrustScoreRegistry.sol` - Internal reputation scores (auditor-driven)
  - **ERC-8004 Registries** (ecosystem compatibility):
    - `IdentityRegistry.sol` - Agent identity as ERC-721 NFTs
    - `ReputationRegistry.sol` - Public feedback bus for agents
    - `ValidationRegistry.sol` - Validation hooks for TEEs/zkML
  - **Test Utilities**:
    - `MockToken.sol` - ERC-20 token for testing staking
  - Hardhat config, deploy scripts, and comprehensive tests (46 tests passing).

- `packages/backend/`
  - Orchestrator:
    - MsgCore ↔ LLM writers ↔ Oasis ROFL ↔ Sapphire contracts.
  - Public verification API:
    - `POST /verify`
    - `GET /status/:contentHash`

- `packages/nextjs/`
  - Frontend UI:
    - ENS-based profiles,
    - user/agent reputation views,
    - list of audited contents with status and score.

---

## Requirements

Before you begin, you need to install:

- [Node (>= v20.18.3)](https://nodejs.org/en/download/)
- Yarn ([v1](https://classic.yarnpkg.com/en/docs/install/) or [v2+](https://yarnpkg.com/getting-started/install))
- [Git](https://git-scm.com/downloads)

---

## Quickstart (Scaffold‑ETH 2)

To get started with the Scaffold‑ETH 2 based stack:

1. Install dependencies (if it was skipped by the CLI):

```bash
yarn install
````

2. Run a local network in the first terminal:

```bash
yarn chain
```

This command starts a local Ethereum network using Hardhat.
The network runs on your local machine and can be used for testing and development.
You can customize the network configuration in `packages/hardhat/hardhat.config.ts`.

3. On a second terminal, deploy the contracts:

```bash
yarn deploy
```

This command deploys the smart contracts to the local network.
Contracts live in `packages/hardhat/contracts` and can be modified to suit AgentCred’s needs.
The `yarn deploy` command uses the deploy scripts in `packages/hardhat/deploy`.

4. On a third terminal, start your NextJS app:

```bash
yarn start
```

Visit your app at: `http://localhost:3000`.

You can:

* interact with your smart contracts via the `Debug Contracts` page,
* tweak app config in `packages/nextjs/scaffold.config.ts`,
* edit your frontend homepage at `packages/nextjs/app/page.tsx`.

Run smart contract tests with:

```bash
yarn hardhat:test
```

Edit:

* smart contracts in `packages/hardhat/contracts`,
* deployment scripts in `packages/hardhat/deploy`,
* frontend routes and layouts under `packages/nextjs/app/`.
