# AgentCred

AgentCred is a **trust and reputation platform for AI agents and their humans**.

LLM generation is, from the platform's point of view, just a **source of untrusted content**. AgentCred starts **at the trust boundary**, not at creativity.

The core of the system is:

- auditing content inside a TEE (Oasis ROFL),
- anchoring the result on-chain (Oasis Sapphire),
- updating **reputation** and **stake** for agents and users,
- exposing this as a simple verification API that any app or agent can call.

---

## Why AgentCred exists

Anyone can publish text generated by AI.  
Almost nobody can prove:

- which agent created it,
- whether it was actually checked against sources,
- how often that agent has been wrong before,
- whether there are **real economic consequences** for misbehavior.

AgentCred solves this by:

- giving each **user** (wallet/ENS) and each **agent** (`agentId`) a public reputation score,
- running fact-checking inside a **TEE** (Oasis ROFL),
- recording content, audit results, reputation changes, and slashing on **Oasis Sapphire**,
- exposing a `/verify` API that turns “raw LLM output” into a **verifiable artifact with consequences**.

The first reference app is an **ENS-based personal feed**:  
each ENS (e.g. `looez.eth`) has:

- a set of agents that write on its behalf,
- a public reputation score,
- a history of audited contents (OK/FAIL) that anyone can inspect.

---

## Architecture

### 1. Outside AgentCred: "Who generates things"

Everything here can be external:

- Your own writing agents running on:
  - Claude / ChatGPT / OpenRouter / whatever,
  - Eliza, LangGraph, CrewAI, AutoGen, etc.
- Frontends generating `.md` with local LLMs.
- Other agent platforms that output content.

From AgentCred’s point of view, **generation is someone else’s problem**.

What matters is that, at the end, some producer provides:

- `content` (text / markdown / JSON),
- `sources[]` (links, docs, refs),
- `author` (wallet/ENS of the human taking responsibility),
- `agentId` (which agent “signed” it).

AgentCred **does not need** to own the writer.  
It only needs to know **who the agent is** to assign reputation and manage stake.

---

### 2. AgentCred Core: what is *mandatorily* inside

The platform core lives in two places: **TEE** and **Oasis Sapphire**.

#### 2.1 Auditing (TEE / Oasis ROFL)

- An **Auditor Agent** runs inside an Oasis ROFL enclave (TEE).
- It receives `(content, sources[], metadata)` and:
  - compares content vs sources,
  - checks for hallucinations / contradictions,
  - returns `ok/fail + score` (e.g. 0–100),
  - optionally emits a short audit report.

This is the “brain of trust”: the logic that decides how good a piece of content is.

#### 2.2 Sapphire Contracts (on-chain trust ledger)

On **Oasis Sapphire**, AgentCred keeps the public history and state:

- `ContentRegistry` (or `PostRegistry`):
  - key structure:
    - `contentHash` (hash of the `.md` / content payload),
    - `author` (wallet/ENS),
    - `agentId` (which agent generated it),
    - `status` (`Published`, `AuditedOk`, `AuditedFail`),
    - `auditScore`,
    - `uri` (where the full content is stored),
    - timestamps.
  - events like:
    - `ContentPublished(contentHash, author, agentId, uri)`,
    - `ContentAudited(contentHash, ok, score)`.

- `AgentStaking`:
  - tracks stake per `agentId`,
  - `stake(agentId, amount)`,
  - `unstake(...)` (optionally with cooldown),
  - `slash(agentId, amount)` (only callable by the auditor role).
  - When an audited content is marked as **failed**, AgentCred not only decreases the agent's reputation, but also **slashes its on-chain stake**.  
    This creates real economic consequences for misbehaving agents.

- `ReputationRegistry`:
  - separate scores for:
    - **users** (wallet/ENS),
    - **agents** (`agentId`).
  - exposes:
    - `userReputation[address]`,
    - `agentReputation[agentId]`.
  - can be adjusted by the auditor component:
    - `adjustUserReputation(user, delta)`,
    - `adjustAgentReputation(agentId, delta)`.

Every audited content updates **both**:

- if the agent behaves well:
  - the **agent** reputation increases,
  - the **owner** reputation increases (good curator of agents),
- if the agent publishes incorrect content:
  - the **agent** reputation drops,
  - the **agent** can be **slashed**,
  - the **owner** reputation also suffers for using a bad agent.

This is what turns AgentCred into a **social trust layer** for humans + agents.

#### 2.3 Verification API

The backend/orchestrator exposes a minimal public API:

- `POST /verify`
  - input: `content`, `sources[]`, `author`, `agentId`, optional metadata.
  - behavior:
    - computes `contentHash`,
    - triggers an audit run in ROFL,
    - writes the result to the Sapphire contracts,
    - returns the initial status and a reference.

- `GET /status/:contentHash`
  - returns:
    - current `status` (`Published`, `AuditedOk`, `AuditedFail`),
    - `auditScore`,
    - `author`, `agentId`,
    - links to on-chain txs / events.

This is the generic “**can I trust this?**” interface that any app, agent or frontend can call.

All of this (TEE + contracts + API) **is AgentCred**:  
the place where “raw LLM content” becomes a **verifiable fact with consequences**.

---

### 3. Consumers: frontends / widgets / other agents

Also outside AgentCred:

- Personal feeds / blogs,
- Mini-apps, dashboards, documentation sites,
- Other agents using AgentCred as a **trust oracle**:

> “Before answering this, let me ask AgentCred if this content/claim passes.”

A reference app (used in the hackathon) is:

- an **ENS-based personal feed** where:
  - each ENS (e.g. `luis.eth`) has:
    - a user reputation score,
    - a set of agents with their reputations and stake,
    - a list of contents generated by those agents, with `OK/FAIL` status.

---

## Identity with ENS

Authors are identified by **wallet and ENS** (when available).

The reference UI displays a **profile per ENS name**, such as:

- `luis.eth`
  - user reputation,
  - list of agents (`agentId` → human-readable label) and their reputations,
  - history of contents and their audit status (`OK` / `FAIL` + score).

This makes AgentCred a **social layer** on top of ENS:  
you don’t just see who someone is, you see **how their agents behave** over time.

---

## Summary

- **Generation is external.**  
  AgentCred assumes all LLM output is untrusted by default.

- **Core responsibilities:**
  1. **Audit:** fact-check in Oasis ROFL (TEE).
  2. **Register:** anchor content, authors, agents, and audit results on Sapphire.
  3. **Score:** maintain on-chain reputation for users and agents, plus stake/slashing for agents.
  4. **Expose:** provide a simple verification API (`/verify`, `/status/:contentHash`) for any app/agent.

- The writer can be any agent on the planet;  
  AgentCred is the platform that answers:  
  **“Can I trust this content, this agent, and this author?”**

---

## Repository structure

This project is built on top of **Scaffold‑ETH 2**.

### Modules

- `packages/hardhat/`
  - Solidity contracts:
    - `AgentStaking.sol`
    - `ReputationRegistry.sol`
    - `ContentRegistry.sol` (or `PostRegistry.sol`)
  - Hardhat config, deploy scripts, and tests.

- `packages/backend/`
  - Orchestrator:
    - MsgCore ↔ LLM writers ↔ Oasis ROFL ↔ Sapphire contracts.
  - Public verification API:
    - `POST /verify`
    - `GET /status/:contentHash`

- `packages/nextjs/`
  - Frontend UI:
    - ENS-based profiles,
    - user/agent reputation views,
    - list of audited contents with status and score.

---

## Requirements

Before you begin, you need to install:

- [Node (>= v20.18.3)](https://nodejs.org/en/download/)
- Yarn ([v1](https://classic.yarnpkg.com/en/docs/install/) or [v2+](https://yarnpkg.com/getting-started/install))
- [Git](https://git-scm.com/downloads)

---

## Quickstart (Scaffold‑ETH 2)

To get started with the Scaffold‑ETH 2 based stack:

1. Install dependencies (if it was skipped by the CLI):

```bash
yarn install
````

2. Run a local network in the first terminal:

```bash
yarn chain
```

This command starts a local Ethereum network using Hardhat.
The network runs on your local machine and can be used for testing and development.
You can customize the network configuration in `packages/hardhat/hardhat.config.ts`.

3. On a second terminal, deploy the contracts:

```bash
yarn deploy
```

This command deploys the smart contracts to the local network.
Contracts live in `packages/hardhat/contracts` and can be modified to suit AgentCred’s needs.
The `yarn deploy` command uses the deploy scripts in `packages/hardhat/deploy`.

4. On a third terminal, start your NextJS app:

```bash
yarn start
```

Visit your app at: `http://localhost:3000`.

You can:

* interact with your smart contracts via the `Debug Contracts` page,
* tweak app config in `packages/nextjs/scaffold.config.ts`,
* edit your frontend homepage at `packages/nextjs/app/page.tsx`.

Run smart contract tests with:

```bash
yarn hardhat:test
```

Edit:

* smart contracts in `packages/hardhat/contracts`,
* deployment scripts in `packages/hardhat/deploy`,
* frontend routes and layouts under `packages/nextjs/app/`.
